% Might be to complicated to make this function work. 
% Requires breakTrue = true, then breaking after function execution...
% And requires returning an input variable without changing it 
% Which matlab hates
% This error: "Output argument "log_likelihood" (and maybe others) not assigned during call to"reset_for_code_break"."
function [...
model,...
predata,...
predataPrev,...
fail_chain,... 
fail_total,... 
iter_fail,...
ii,...
log_likelihood,... 
misfit,...
Pm_prior,... 
nchain,...
breakTrue] = ...
    reset_for_code_break(...
par,... 
model, ...
laymodel,...
Kbase, ...
KbasePrev,...
trudata,...
predata, ...
predataPrev, ...
fail_chain, ...
fail_total,...
iter_fail,...
ii,...
ID,...
chainstr)




if fail_chain > 0; % Problem -- There are various ways of dealing with this.
%     fprintf('\nFail chain: %2.0f. ii = %6.0f',fail_chain, ii)
%%% TODO add in Kbase.numRewinds. If it gets to > 3 or something, go to
%%% prev Kbase.

    resetData = false; 
    failInfoStr = sprintf('\n%s ii=%1.0f Failure. fail_chain = %1.0f, fail_total = %1.0f. ',...
            chainstr, ii, fail_chain, fail_total); 
        
    %%% If early fail
    earlyFailNum = 75; 
    if ii < earlyFailNum; % If chain is giving problems this early, just reset it.
        warning('%sError within first %1.0f iterations. Reseting chain.\n', failInfoStr, earlyFailNum);  
%         warning([failInfoStr 'Error within first 10 iterations. Reseting chain.']); 
        fail_chain = 100; fail_total = fail_total + 1; breakTrue = true; 
    end 
    
    %%% If later fail
    if fail_chain > 15; 
        if ii - Kbase.itersave > 50; % Last Kbase is probably a decent model
            warning([failInfoStr 'High fail chain. Reset to last Kbase.']); 
            model = Kbase.modelk; ii = Kbase.itersave; % Rewind to last model    
            resetData = true; 
        else % Last Kbase might also be bad. Go back two models. 
            if ~isempty(KbasePrev); 
                warning([failInfoStr 'High fail chain. Reset to last KbasePrev (NOT Kbase).']); 
                model = KbasePrev.modelk; ii = KbasePrev.itersave; 
                resetData = true; 
            else; % We don't know if last Kbase is good, and we only have one Kbase. Just reset the chain: we must not be very far anyway.  
                warning([failInfoStr 'High fail chain after reset Kbase, but KbasePrev doesnt exist. Resetting chain.']); 
                fail_chain = 100; fail_total = fail_total + 1; breakTrue = true;
            end
        end
    end
    
    fprintf('\nNow on iteration %1.0f',ii); 
    iter_fail(end+1) = ii; 
    
    if resetData; 
        predata = b3_FORWARD_MODEL_BW( model,laymodel,par,predata,ID,0,predataPrev); % brb2022.04.12 The arguments to forward_model_bw were in the wrong order. Probaly an old version of the code. 
        predata = b3_FORWARD_MODEL_RF_ccp( model,laymodel,par,predata,ID,0 );
        predata = b3_FORWARD_MODEL_SW_kernel( model,Kbase,par,predata );
        predataPrev = predata; % Keep track of last predata. To keep the previous complete HK stack. 
        % need to also reset likelihood and misfit to the new, precise data (likelihood may have been artificially high due to kernel forward  calc. approximation - if so, need to undo this, or chain will get stuck once we reset kernels).
        [log_likelihood,misfit] = b8_LIKELIHOOD_RESET(par,predata,trudata,Kbase,model.datahparm);
        Pm_prior = calc_Pm_prior(model,par);
        nchain = 0;
    end
    %!%! Code to break chain entirely if reset to many times.     
end





end